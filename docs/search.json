[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "A constituição em processo de judicialização",
    "section": "",
    "text": "Apresentação\nEste livro apresenta a documentação da minha pesquisa de dissertação “A constituição em processo de judicialização: um estudo da multidimensionalidade da judicialização da política a partir da análise das arguições de descumprimento de preceito fundamental”, apresentada ao Programa de Pós-Graduação em Direito e Justiça Social (PPGDJS) da Universidade Federal do Rio Grande - FURG, para obtenção do título de Mestre em Direito.\nA dissertação está disponível em: XXX.\nEsse livro foi gerado pela última vez em 2025-06-15 nas seguintes condições:\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.5.1 (2025-06-13 ucrt)\n os       Windows 11 x64 (build 26100)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  Portuguese_Brazil.utf8\n ctype    Portuguese_Brazil.utf8\n tz       America/Sao_Paulo\n date     2025-06-15\n pandoc   3.4 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n D cli           3.6.2   2023-12-11 [1] CRAN (R 4.3.3)\n   digest        0.6.35  2024-03-11 [1] CRAN (R 4.3.3)\n   evaluate      0.23    2023-11-01 [1] CRAN (R 4.3.3)\n   fastmap       1.1.1   2023-02-24 [1] CRAN (R 4.1.3)\n   htmltools     0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n   htmlwidgets   1.6.4   2023-12-06 [1] CRAN (R 4.3.2)\n D jsonlite      1.8.8   2023-12-04 [1] CRAN (R 4.3.3)\n   knitr         1.46    2024-04-06 [1] CRAN (R 4.3.3)\n   rlang         1.1.3   2024-01-10 [1] CRAN (R 4.3.3)\n   rmarkdown     2.29    2024-11-04 [1] CRAN (R 4.3.3)\n   rstudioapi    0.15.0  2023-07-07 [1] CRAN (R 4.1.3)\n   sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.1.3)\n   xfun          0.43    2024-03-25 [1] CRAN (R 4.3.3)\n D yaml          2.3.8   2023-12-11 [1] CRAN (R 4.3.2)\n\n [1] D:/R/R-4.5.1/library\n\n D ── DLL MD5 mismatch, broken installation.\n\n──────────────────────────────────────────────────────────────────────────────",
    "crumbs": [
      "Apresentação"
    ]
  },
  {
    "objectID": "01_introducao.html",
    "href": "01_introducao.html",
    "title": "1  Introdução",
    "section": "",
    "text": "Introdução da dissertação",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "02_metodologia.html",
    "href": "02_metodologia.html",
    "title": "2  Metodologia",
    "section": "",
    "text": "2.1 Coleta de dados\nIntrodução à metodologia\nOs dados foram coletados do portal Corte Aberta do STF, painéis estatísticos de controle concentrado que podem ser acessados aqui. Foram baixados três tabelas do portal e armazenados na pasta DATA/RAW/, conforme Tabela 2.1 abaixo:\nUma vez baixados os dados, eles foram importados utilizando a função readxl::read_xlsx():\n# Importa os processos\n1raw_processos &lt;- readxl::read_xlsx(\"DATA/RAW/raw_processos.xlsx\", na = \"*NI*\")\n\n# Importa as decisões\nraw_decisoes &lt;- readxl::read_xlsx(\"DATA/RAW/raw_decisoes.xlsx\",\n  na = \"*NI*\",\n2  col_types = c(\"guess\", \"date\", \"guess\", \"guess\", \"guess\", \"guess\")\n)\n\n# Importa os legitimados\nraw_legitimados &lt;- readxl::read_xlsx(\"DATA/RAW/raw_legitimados.xlsx\",\n  na = \"*NI*\"\n)\n\n\n1\n\nna = “*NI*”: o STF utiliza o código *NI* para dados faltantes.\n\n2\n\ncol_types: foi preciso na tabela de decisões indicar expressamente o tipo de dado da coluna data\nApós importar os dados, salvei eles em formato .rds para leitura mais posterior mais rápida:\n# Salvar os arquivos raw em rds\nsaveRDS(raw_processos, \"DATA/RAW/raw_processos.rds\")\nsaveRDS(raw_decisoes, \"DATA/RAW/raw_decisoes.rds\")\nsaveRDS(raw_legitimados, \"DATA/RAW/raw_legitimados.rds\")\nO segundo conjunto de dados foram obtidos a partir da raspagem de dados no portal do STF. Primeiro, extraiu-se os dados sobre decisões monocráticas e acórdãos, depois, com base na tabela de acórdãos, foram baixados os arquivos em .pdf dos acórdãos. Para isso, foi utilizado o pacote decJ.\n# Extrai as decisões monocráticas\nraw_monocraticas &lt;- decJ::stf_jurisprudencia(\n  classe = \"ADPF\",\n  base = 'decisoes',\n  quantidade = 3000\n)\n\n# Extrai os acórdãos\nraw_acordaos &lt;- decJ::stf_jurisprudencia(\n  classe = \"ADPF\",\n  base = \"acordaos\",\n  quantidade = 3000\n)\n\n# Salva os arquivos raw em rds\nsaveRDS(raw_monocraticas, \"DATA/RAW/raw_monocraticas.rds\")\nsaveRDS(raw_acordaos, \"DATA/RAW/raw_acordaos.rds\")\nA função decJ::stf_jurisprudencia() funciona da seguinte forma:\n# Função stf_jurisprudencia do pacote decJ\n\nstf_jurisprudencia = function(busca = NULL, classe = NULL, base = c(\"acordaos\", \"decisoes\"), quantidade = 25){\n\n1  header &lt;- httr::add_headers(\"User-Agent\" = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.51\")\n\n2  if (!is.null(busca) & is.null(classe)) {\n    body &lt;- busca_jurisprudencia\n    body$query$bool$filter[[1]]$query_string$query &lt;- busca\n    body$post_filter$bool$must[[1]]$term$base &lt;- base\n  } else if (is.null(busca) & !is.null(classe)) {\n    body &lt;- busca_classe\n    body$query$bool$filter$query_string$query &lt;- classe\n    body$post_filter$bool$must$term$base &lt;- base\n  } else if ((!is.null(busca) & !is.null(classe))) {\n    cli::cli_alert_danger(\"Essa funcao so funciona com busca por palavras chaves OU por classe. Ainda estamos desenvolvendo uma forma de trabalhar com as duas buscas juntas.\")\n    return(NULL)\n  }\n\n3  num_iteracoes &lt;- ceiling(quantidade / 250)\n\n  if (quantidade &gt; 250) {\n    body$size &lt;- 250\n  } else {\n    body$size &lt;- quantidade\n  }\n \n  purrr::map_dfr(1:num_iteracoes, purrr::slowly(~{ \n    body$from &lt;- (.x - 1) * 250\n4    htmlSTF &lt;- httr::POST(\n      \"https://jurisprudencia.stf.jus.br/api/search/search\",\n      body = body,\n      encode = \"json\", header\n    )\n    getContent &lt;- jsonlite::fromJSON(httr::content(htmlSTF, \"text\"))\n    dados &lt;- getContent$result$hits$hits$`_source`\n  }, rate = purrr::rate_delay(5)), .progress = list(format = \"Extraindo {cli::pb_bar} {cli::pb_elapsed}\")) \n}\n\n\n1\n\nAdicionar um User_Agent\n\n2\n\nA função ainda não consegue fazer buscas por palavras-chave e classe, portanto, nesse momento ela identifica se a busca está sendo feita por palavras chave ou por classe e, então, utiliza o body da requisição correto para o tipo de busca. Caso o usuário coloque classe e palavra-chave, a função retorna um erro.\n\n3\n\nComo a API do STF não permite fazer mais do que 250 buscas por vez, aqui ele verifica a quantidade que está sendo buscada e divide por 250 para identificar a quantidade de requisições que serão necessárias.\n\n4\n\nA requisição é feita e como resultado temos uma tabela com os dados solicitados.\nEstas então foram as formas de coletar os dados brutos. Abaixo podemos observar a estrutura dessas tabelas:\nTabela\nNº Colunas\nNº Linhas\nNº de Dados\n\n\n\n\nraw_processos\n32\n8355\n267360\n\n\nraw_decisoes\n6\n17734\n106404\n\n\nraw_legitimados\n3\n16687\n50061\n\n\nraw_acordaos\n57\n632\n36024\n\n\nraw_monocraticas\n37\n1571\n58127",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Metodologia</span>"
    ]
  },
  {
    "objectID": "02_metodologia.html#coleta-de-dados",
    "href": "02_metodologia.html#coleta-de-dados",
    "title": "2  Metodologia",
    "section": "",
    "text": "Tabela 2.1\n\n\n\n\n\nTabela\nDescrição\nArquivo\nData\n\n\n\n\nProcessos\nContém as informações gerais sobre os processos de controle concentrado\nraw_processos.xlsx\n06/06/2025\n\n\nDecisões\nContém as informações sobre as decisões tomadas em sede de controle concentrado\nraw_decisoes.xlsx\n06/06/2025\n\n\nLegitimados\nContém as informações sobre os legitimados ativos e legitimados passivos nas ações de controle concentrado\nraw_legitimados.xlsx\n06/06/2025",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Metodologia</span>"
    ]
  },
  {
    "objectID": "02_metodologia.html#limpeza-dos-dados",
    "href": "02_metodologia.html#limpeza-dos-dados",
    "title": "2  Metodologia",
    "section": "2.2 Limpeza dos dados",
    "text": "2.2 Limpeza dos dados\nUma vez obtidos os dados brutos, foi preciso fazer uma faxina inicial. Primeiro, limpei o nome das variáveis:\n\n# Limpa o nome das variáveis\nclean_processos &lt;- janitor::clean_names(raw_processos)\nclean_decisoes &lt;- janitor::clean_names(raw_decisoes)\nclean_legitimados &lt;- janitor::clean_names(raw_legitimados)\nclean_acordaos &lt;- janitor::clean_names(raw_acordaos)\nclean_monocraticas &lt;- janitor::clean_names(raw_monocraticas)\n\nApós a limpeza dos nomes das variáveis de todas as tabelas, passei a limpar tabelas específicas. Começando pela tabela de processos (clean_processos).\nSerão feitas limpezas específicas dos dados a depender da análise. Essas limpezas estarão descritas no momento da análise no capítulo respectivo. Ademais, todo o código está compilado no Apêndice A",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Metodologia</span>"
    ]
  },
  {
    "objectID": "02_metodologia.html#análise-de-dados-quantitativos",
    "href": "02_metodologia.html#análise-de-dados-quantitativos",
    "title": "2  Metodologia",
    "section": "2.3 Análise de dados quantitativos",
    "text": "2.3 Análise de dados quantitativos\nEstatísticas descritivas…\n\n2.3.1 Análise de Sobrevivência\nA análise de sobrevivência (survival analysis) permitirá inferir sobre a duração dos processos. Inicialmente, empregou-se a análise de sobrevivência de Kaplan-Meier para avaliar o tempo em dias entre a autuação e a baixa de um processo. Este método não-paramétrico é fundamental para estudos longitudinais onde o desfecho é o tempo decorrido até um evento específico, tendo como principal vantagem a capacidade de incorporar dados de censura – isto é, quando durante o período de análise o evento não acontece para determinados casos.\nA função \\(S(t)\\) representa a probabilidade de um indivíduo sobreviver por um tempo superior a \\(t\\). A análise gera uma curva em degraus, onde cada degrau descendente corresponde ao momento em que um ou mais eventos ocorreram. A construção da curva baseia-se na fórmula do estimador de Kaplan-Meier (Equação 2.1), que calcula a probabilidade de sobrevivência acumulada em diferentes pontos no tempo.\n\\[\n\\hat{S}(t) = \\prod_{i|t_i\\leq t}(1-\\frac{d_i}{n_i})\n\\tag{2.1}\\]\nEssencialmente, a fração \\(\\frac{d_i}{n_i}\\) representa a probabilidade de o evento ocorrer no tempo \\(t\\). Consequentemente, o termo \\((1-\\frac{d_i}{n_i})\\) representa a probabilidade de sobreviver àquele ponto de evento. A fórmula, portanto, calcula a sobrevivêmcia acumulada multiplicando essas probabilidades de sobrevivência em cada ponto de evento ao longo do tempo.\n\n\n2.3.2 Regressão Logística",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Metodologia</span>"
    ]
  },
  {
    "objectID": "02_metodologia.html#análise-de-dados-qualitativos",
    "href": "02_metodologia.html#análise-de-dados-qualitativos",
    "title": "2  Metodologia",
    "section": "2.4 Análise de dados qualitativos",
    "text": "2.4 Análise de dados qualitativos",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Metodologia</span>"
    ]
  },
  {
    "objectID": "code.html",
    "href": "code.html",
    "title": "Apêndice A — Código",
    "section": "",
    "text": "Introdução",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Código</span>"
    ]
  },
  {
    "objectID": "code.html#metodologia",
    "href": "code.html#metodologia",
    "title": "Apêndice A — Código",
    "section": "Metodologia",
    "text": "Metodologia\n\nknitr::opts_chunk$set(\n  warning = FALSE, error = FALSE, message = FALSE\n)\n\n# Importa os processos\nraw_processos &lt;- readxl::read_xlsx(\"DATA/RAW/raw_processos.xlsx\", na = \"*NI*\")\n\n# Importa as decisões\nraw_decisoes &lt;- readxl::read_xlsx(\"DATA/RAW/raw_decisoes.xlsx\",\n  na = \"*NI*\",\n  col_types = c(\"guess\", \"date\", \"guess\", \"guess\", \"guess\", \"guess\")\n)\n\n# Importa os legitimados\nraw_legitimados &lt;- readxl::read_xlsx(\"DATA/RAW/raw_legitimados.xlsx\",\n  na = \"*NI*\"\n)\n\n# Salvar os arquivos raw em rds\nsaveRDS(raw_processos, \"DATA/RAW/raw_processos.rds\")\nsaveRDS(raw_decisoes, \"DATA/RAW/raw_decisoes.rds\")\nsaveRDS(raw_legitimados, \"DATA/RAW/raw_legitimados.rds\")\n\n# Extrai as decisões monocráticas\nraw_monocraticas &lt;- decJ::stf_jurisprudencia(\n  classe = \"ADPF\",\n  base = 'decisoes',\n  quantidade = 3000\n)\n\n# Extrai os acórdãos\nraw_acordaos &lt;- decJ::stf_jurisprudencia(\n  classe = \"ADPF\",\n  base = \"acordaos\",\n  quantidade = 3000\n)\n\n# Salva os arquivos raw em rds\nsaveRDS(raw_monocraticas, \"DATA/RAW/raw_monocraticas.rds\")\nsaveRDS(raw_acordaos, \"DATA/RAW/raw_acordaos.rds\")\n\n# Função stf_jurisprudencia do pacote decJ\n\nstf_jurisprudencia = function(busca = NULL, classe = NULL, base = c(\"acordaos\", \"decisoes\"), quantidade = 25){\n\n  header &lt;- httr::add_headers(\"User-Agent\" = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.51\")\n\n  if (!is.null(busca) & is.null(classe)) {\n    body &lt;- busca_jurisprudencia\n    body$query$bool$filter[[1]]$query_string$query &lt;- busca\n    body$post_filter$bool$must[[1]]$term$base &lt;- base\n  } else if (is.null(busca) & !is.null(classe)) {\n    body &lt;- busca_classe\n    body$query$bool$filter$query_string$query &lt;- classe\n    body$post_filter$bool$must$term$base &lt;- base\n  } else if ((!is.null(busca) & !is.null(classe))) {\n    cli::cli_alert_danger(\"Essa funcao so funciona com busca por palavras chaves OU por classe. Ainda estamos desenvolvendo uma forma de trabalhar com as duas buscas juntas.\")\n    return(NULL)\n  }\n\n  num_iteracoes &lt;- ceiling(quantidade / 250)\n\n  if (quantidade &gt; 250) {\n    body$size &lt;- 250\n  } else {\n    body$size &lt;- quantidade\n  }\n \n  purrr::map_dfr(1:num_iteracoes, purrr::slowly(~{ \n    body$from &lt;- (.x - 1) * 250\n    htmlSTF &lt;- httr::POST(\n      \"https://jurisprudencia.stf.jus.br/api/search/search\",\n      body = body,\n      encode = \"json\", header\n    )\n    getContent &lt;- jsonlite::fromJSON(httr::content(htmlSTF, \"text\"))\n    dados &lt;- getContent$result$hits$hits$`_source`\n  }, rate = purrr::rate_delay(5)), .progress = list(format = \"Extraindo {cli::pb_bar} {cli::pb_elapsed}\")) \n}\n\nraw_processos &lt;- readRDS('DATA/RAW/raw_processos.rds')\nraw_decisoes &lt;- readRDS('DATA/RAW/raw_decisoes.rds')\nraw_legitimados &lt;- readRDS('DATA/RAW/raw_legitimados.rds')\nraw_monocraticas &lt;- readRDS('DATA/RAW/raw_monocraticas.rds')\nraw_acordaos &lt;- readRDS('DATA/RAW/raw_acordaos.rds')\n\ntibble::tribble(\n  ~\"Tabela\", ~\"Nº Colunas\", ~\"Nº Linhas\", ~\"Nº de Dados\",\n  \"raw_processos\", ncol(raw_processos), nrow(raw_processos), ncol(raw_processos) * nrow(raw_processos),\n  \"raw_decisoes\", ncol(raw_decisoes), nrow(raw_decisoes), ncol(raw_decisoes) * nrow(raw_decisoes),\n  \"raw_legitimados\", ncol(raw_legitimados), nrow(raw_legitimados), ncol(raw_legitimados) * nrow(raw_legitimados),\n  \"raw_acordaos\", ncol(raw_acordaos), nrow(raw_acordaos), ncol(raw_acordaos) * nrow(raw_acordaos),\n  \"raw_monocraticas\", ncol(raw_monocraticas), nrow(raw_monocraticas), ncol(raw_monocraticas) * nrow(raw_monocraticas)\n) |&gt; knitr::kable()\n\n# Limpa o nome das variáveis\nclean_processos &lt;- janitor::clean_names(raw_processos)\nclean_decisoes &lt;- janitor::clean_names(raw_decisoes)\nclean_legitimados &lt;- janitor::clean_names(raw_legitimados)\nclean_acordaos &lt;- janitor::clean_names(raw_acordaos)\nclean_monocraticas &lt;- janitor::clean_names(raw_monocraticas)",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Código</span>"
    ]
  }
]