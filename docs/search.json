[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "A constituição em processo de judicialização",
    "section": "",
    "text": "Apresentação\nEste livro apresenta a documentação da minha pesquisa de dissertação “A constituição em processo de judicialização: um estudo da multidimensionalidade da judicialização da política a partir da análise das arguições de descumprimento de preceito fundamental”, apresentada ao Programa de Pós-Graduação em Direito e Justiça Social (PPGDJS) da Universidade Federal do Rio Grande - FURG, para obtenção do título de Mestre em Direito.\nA dissertação está disponível em: XXX.\nEsse livro foi gerado pela última vez em 2025-06-16 nas seguintes condições:\n\n\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.5.1 (2025-06-13 ucrt)\n os       Windows 11 x64 (build 26100)\n system   x86_64, mingw32\n ui       RTerm\n language (EN)\n collate  Portuguese_Brazil.utf8\n ctype    Portuguese_Brazil.utf8\n tz       America/Sao_Paulo\n date     2025-06-15\n pandoc   3.4 @ C:/Program Files/RStudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)\n\n─ Packages ───────────────────────────────────────────────────────────────────\n ! package     * version date (UTC) lib source\n D cli           3.6.2   2023-12-11 [1] CRAN (R 4.3.3)\n   digest        0.6.35  2024-03-11 [1] CRAN (R 4.3.3)\n   evaluate      0.23    2023-11-01 [1] CRAN (R 4.3.3)\n   fastmap       1.1.1   2023-02-24 [1] CRAN (R 4.1.3)\n   htmltools     0.5.7   2023-11-03 [1] CRAN (R 4.3.2)\n   htmlwidgets   1.6.4   2023-12-06 [1] CRAN (R 4.3.2)\n D jsonlite      1.8.8   2023-12-04 [1] CRAN (R 4.3.3)\n   knitr         1.46    2024-04-06 [1] CRAN (R 4.3.3)\n   rlang         1.1.3   2024-01-10 [1] CRAN (R 4.3.3)\n   rmarkdown     2.29    2024-11-04 [1] CRAN (R 4.3.3)\n   rstudioapi    0.15.0  2023-07-07 [1] CRAN (R 4.1.3)\n   sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.1.3)\n   xfun          0.43    2024-03-25 [1] CRAN (R 4.3.3)\n D yaml          2.3.8   2023-12-11 [1] CRAN (R 4.3.2)\n\n [1] D:/R/R-4.5.1/library\n\n D ── DLL MD5 mismatch, broken installation.\n\n──────────────────────────────────────────────────────────────────────────────",
    "crumbs": [
      "Apresentação"
    ]
  },
  {
    "objectID": "01_introducao.html",
    "href": "01_introducao.html",
    "title": "1  Introdução",
    "section": "",
    "text": "Introdução da dissertação",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introdução</span>"
    ]
  },
  {
    "objectID": "02_metodologia.html",
    "href": "02_metodologia.html",
    "title": "2  Metodologia",
    "section": "",
    "text": "2.1 Coleta de dados\nIntrodução à metodologia\nOs dados foram coletados do portal Corte Aberta do STF, painéis estatísticos de controle concentrado que podem ser acessados aqui. Foram baixados três tabelas do portal e armazenados na pasta DATA/RAW/, conforme Tabela 2.1 abaixo:\nUma vez baixados os dados, eles foram importados utilizando a função readxl::read_xlsx():\n# Importa os processos\n1raw_processos &lt;- readxl::read_xlsx(\"DATA/RAW/raw_processos.xlsx\", na = \"*NI*\")\n\n# Importa as decisões\nraw_decisoes &lt;- readxl::read_xlsx(\"DATA/RAW/raw_decisoes.xlsx\",\n  na = \"*NI*\",\n2  col_types = c(\"guess\", \"date\", \"guess\", \"guess\", \"guess\", \"guess\")\n)\n\n# Importa os legitimados\nraw_legitimados &lt;- readxl::read_xlsx(\"DATA/RAW/raw_legitimados.xlsx\",\n  na = \"*NI*\"\n)\n\n\n1\n\nna = “*NI*”: o STF utiliza o código *NI* para dados faltantes.\n\n2\n\ncol_types: foi preciso na tabela de decisões indicar expressamente o tipo de dado da coluna data\nApós importar os dados, salvei eles em formato .rds para leitura mais posterior mais rápida:\n# Salvar os arquivos raw em rds\nsaveRDS(raw_processos, \"DATA/RAW/raw_processos.rds\")\nsaveRDS(raw_decisoes, \"DATA/RAW/raw_decisoes.rds\")\nsaveRDS(raw_legitimados, \"DATA/RAW/raw_legitimados.rds\")\nO segundo conjunto de dados foram obtidos a partir da raspagem de dados no portal do STF. Primeiro, extraiu-se os dados sobre decisões monocráticas e acórdãos, depois, com base na tabela de acórdãos, foram baixados os arquivos em .pdf dos acórdãos. Para isso, foi utilizado o pacote decJ.\n# Extrai as decisões monocráticas\nraw_monocraticas &lt;- decJ::stf_jurisprudencia(\n  classe = \"ADPF\",\n  base = 'decisoes',\n  quantidade = 3000\n)\n\n# Extrai os acórdãos\nraw_acordaos &lt;- decJ::stf_jurisprudencia(\n  classe = \"ADPF\",\n  base = \"acordaos\",\n  quantidade = 3000\n)\n\n# Salva os arquivos raw em rds\nsaveRDS(raw_monocraticas, \"DATA/RAW/raw_monocraticas.rds\")\nsaveRDS(raw_acordaos, \"DATA/RAW/raw_acordaos.rds\")\nA função decJ::stf_jurisprudencia() funciona da seguinte forma:\n# Função stf_jurisprudencia do pacote decJ\n\nstf_jurisprudencia = function(busca = NULL, classe = NULL, base = c(\"acordaos\", \"decisoes\"), quantidade = 25){\n\n1  header &lt;- httr::add_headers(\"User-Agent\" = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.51\")\n\n2  if (!is.null(busca) & is.null(classe)) {\n    body &lt;- busca_jurisprudencia\n    body$query$bool$filter[[1]]$query_string$query &lt;- busca\n    body$post_filter$bool$must[[1]]$term$base &lt;- base\n  } else if (is.null(busca) & !is.null(classe)) {\n    body &lt;- busca_classe\n    body$query$bool$filter$query_string$query &lt;- classe\n    body$post_filter$bool$must$term$base &lt;- base\n  } else if ((!is.null(busca) & !is.null(classe))) {\n    cli::cli_alert_danger(\"Essa funcao so funciona com busca por palavras chaves OU por classe. Ainda estamos desenvolvendo uma forma de trabalhar com as duas buscas juntas.\")\n    return(NULL)\n  }\n\n3  num_iteracoes &lt;- ceiling(quantidade / 250)\n\n  if (quantidade &gt; 250) {\n    body$size &lt;- 250\n  } else {\n    body$size &lt;- quantidade\n  }\n \n  purrr::map_dfr(1:num_iteracoes, purrr::slowly(~{ \n    body$from &lt;- (.x - 1) * 250\n4    htmlSTF &lt;- httr::POST(\n      \"https://jurisprudencia.stf.jus.br/api/search/search\",\n      body = body,\n      encode = \"json\", header\n    )\n    getContent &lt;- jsonlite::fromJSON(httr::content(htmlSTF, \"text\"))\n    dados &lt;- getContent$result$hits$hits$`_source`\n  }, rate = purrr::rate_delay(5)), .progress = list(format = \"Extraindo {cli::pb_bar} {cli::pb_elapsed}\")) \n}\n\n\n1\n\nAdicionar um User_Agent\n\n2\n\nA função ainda não consegue fazer buscas por palavras-chave e classe, portanto, nesse momento ela identifica se a busca está sendo feita por palavras chave ou por classe e, então, utiliza o body da requisição correto para o tipo de busca. Caso o usuário coloque classe e palavra-chave, a função retorna um erro.\n\n3\n\nComo a API do STF não permite fazer mais do que 250 buscas por vez, aqui ele verifica a quantidade que está sendo buscada e divide por 250 para identificar a quantidade de requisições que serão necessárias.\n\n4\n\nA requisição é feita e como resultado temos uma tabela com os dados solicitados.\nEstas então foram as formas de coletar os dados brutos. Abaixo podemos observar a estrutura dessas tabelas:\nTabela\nNº Colunas\nNº Linhas\nNº de Dados\n\n\n\n\nraw_processos\n32\n8355\n267360\n\n\nraw_decisoes\n6\n17734\n106404\n\n\nraw_legitimados\n3\n16687\n50061\n\n\nraw_acordaos\n57\n632\n36024\n\n\nraw_monocraticas\n37\n1571\n58127",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Metodologia</span>"
    ]
  },
  {
    "objectID": "02_metodologia.html#coleta-de-dados",
    "href": "02_metodologia.html#coleta-de-dados",
    "title": "2  Metodologia",
    "section": "",
    "text": "Tabela 2.1\n\n\n\n\n\nTabela\nDescrição\nArquivo\nData\n\n\n\n\nProcessos\nContém as informações gerais sobre os processos de controle concentrado\nraw_processos.xlsx\n06/06/2025\n\n\nDecisões\nContém as informações sobre as decisões tomadas em sede de controle concentrado\nraw_decisoes.xlsx\n06/06/2025\n\n\nLegitimados\nContém as informações sobre os legitimados ativos e legitimados passivos nas ações de controle concentrado\nraw_legitimados.xlsx\n06/06/2025",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Metodologia</span>"
    ]
  },
  {
    "objectID": "02_metodologia.html#limpeza-dos-dados",
    "href": "02_metodologia.html#limpeza-dos-dados",
    "title": "2  Metodologia",
    "section": "2.2 Limpeza dos dados",
    "text": "2.2 Limpeza dos dados\nUma vez obtidos os dados brutos, foi preciso fazer uma faxina inicial. Primeiro, limpei o nome das variáveis:\n\n# Limpa o nome das variáveis\nclean_processos &lt;- janitor::clean_names(raw_processos)\nclean_decisoes &lt;- janitor::clean_names(raw_decisoes)\nclean_legitimados &lt;- janitor::clean_names(raw_legitimados)\nclean_acordaos &lt;- janitor::clean_names(raw_acordaos)\nclean_monocraticas &lt;- janitor::clean_names(raw_monocraticas)\n\nApós a limpeza dos nomes das variáveis de todas as tabelas, passei a limpar tabelas específicas. Começando pela tabela de processos (clean_processos).\n\nclean_processos &lt;- clean_processos |&gt;\n  # seleciona as colunas que serão utilizadas\n  dplyr::select(\n    processo, link_processo, relator_atual, ramo_do_direito, assunto_relacionado, data_autuacao, data_transito_julgado, data_baixa, em_tramitacao, tem_rito_art_12, legislacao\n  ) |&gt;\n  # transforma as colunas de data \n  dplyr::mutate(\n    data_autuacao = lubridate::ymd(as.Date(data_autuacao)),\n    data_transito_julgado = lubridate::ymd(as.Date(data_transito_julgado)),\n    data_baixa = lubridate::ymd(as.Date(data_baixa, format = \"%d/%m/%Y\"))\n  ) |&gt;\n  # separa processo em classe e numero\n  tidyr::separate(\n    processo,\n    into = c(\"classe\", \"numero\"),\n    sep = \"\\\\s\"\n  ) |&gt;\n  # separa os assuntos relacionados\n  tidyr::separate_rows(\n    assunto_relacionado,\n    sep = \"\\\\|\"\n  ) |&gt;\n  # separa a legislação\n  tidyr::separate_rows(\n    legislacao,\n    sep = \"\\\\r\"\n  )\n\n# Salva a tabela limpa\nsaveRDS(clean_processos, \"DATA/CLEAN/clean_processos.rds\")\n\nSerão feitas limpezas específicas dos dados a depender da análise. Essas limpezas estarão descritas no momento da análise no capítulo respectivo. Ademais, todo o código está compilado no Apêndice A",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Metodologia</span>"
    ]
  },
  {
    "objectID": "02_metodologia.html#análise-quantitativa",
    "href": "02_metodologia.html#análise-quantitativa",
    "title": "2  Metodologia",
    "section": "2.3 Análise quantitativa",
    "text": "2.3 Análise quantitativa\nEstatísticas descritivas…\n\n2.3.1 Análise de Sobrevivência\nEste trabalho incorpora uma abordagem quantitativa para investigar um aspecto crucial da prestação jurisdicional: o tempo. A duração de um processo judicial não é um mero detalhe procedimental; ela representa o tempo em que a sociedade, os atores políticos e os cidadãos aguardam por uma definição do judiciário sobre questões de elevada magnitude. A morosidade ou a celeridade do STF impacta diretamente a segurança jurídica, a estabilidade das relações políticas e a própria efetividade dos direitos. Para mensurar e analisar rigorosamente este fator temporal, a metodologia empregada será a análise de sobrevivência, uma técnica estatística que permite estudar a duração da tramitação processual até a ocorrência de um evento de interesse, que, no escopo desta pesquisa, foi definido como a baixa definitiva do processo.\nA análise de sobrevivência é um conjunto de métodos estatísticos cujo objetivo primordial é analisar o tempo decorrido desde um marco inicial até a ocorrência de um determinado evento. Embora suas origens remontem às ciências médicas — onde era classicamente utilizada para estudar o tempo de sobrevida de pacientes após um diagnóstico ou tratamento —, sua aplicabilidade foi expandida para diversas outras áreas, como engenharia (análise de falha de equipamentos), economia (duração do desemprego) e, como no presente caso, o direito. No contexto jurídico-processual, o “tempo de sobrevivência” de um processo pode ser entendido como o período em que ele permanece ativo, ou “vivo”, no sistema de justiça. O “evento” de interesse, análogo à “morte” no estudo clínico, é a sua conclusão, ou seja, a sua baixa definitiva após o trânsito em julgado. Esta metodologia permite-nos ir além de simples médias ou medianas de duração, oferecendo uma visão dinâmica de como a probabilidade de um processo ser finalizado evolui ao longo do tempo.\nUm dos desafios mais significativos na análise de dados temporais em pesquisas jurídicas é a presença de “dados censurados”. A censura ocorre quando não observamos o evento de interesse para todos os sujeitos da nossa amostra durante o período de estudo. Em nossa pesquisa, que abrange as ADPFs distribuídas até uma data de corte específica, inevitavelmente encontraremos processos que, ao final do período de coleta de dados, ainda estão em tramitação. Esses processos são os nossos dados censurados. Simplesmente ignorá-los ou tratá-los como se tivessem sido finalizados na data de corte introduziria um viés severo na análise, subestimando drasticamente o tempo real de tramitação. A grande vantagem da análise de sobrevivência, e especificamente do método de Kaplan-Meier que adotaremos, é sua capacidade de incorporar essa informação parcial dos dados censurados de forma elegante e precisa, utilizando a informação de que eles “sobreviveram” pelo menos até o final do período de observação, sem presumir quando serão de fato concluídos.\nPara contornar o problema dos dados censurados e estimar a função de sobrevivência dos processos de ADPF, esta dissertação empregará o estimador de Kaplan-Meier. Trata-se de um método não paramétrico, o que representa uma vantagem considerável, pois não nos obriga a fazer pressuposições sobre a distribuição estatística subjacente dos tempos de tramitação dos processos. Em outras palavras, não precisamos assumir que os tempos de julgamento seguem uma forma matemática pré-definida. O método de Kaplan-Meier utiliza a informação disponível no momento exato em que cada processo é finalizado para recalcular, passo a passo, a probabilidade de um processo qualquer “sobreviver”, ou seja, permanecer ativo, para além daquele ponto no tempo. O resultado é uma estimativa mais realista e detalhada da dinâmica temporal da jurisdição constitucional, apresentada geralmente por meio de uma função em escada, conhecida como curva de Kaplan-Meier.\nA fórmula matemática que fundamenta o estimador de Kaplan-Meier, embora possa parecer complexa à primeira vista, baseia-se em uma lógica bastante intuitiva. A probabilidade de um processo sobreviver para além de um tempo \\(t\\), denotada por \\(S(t)\\), é calculada pelo produto das probabilidades de sobrevivência em cada um dos momentos em que ocorre um evento (a baixa de um processo) até o tempo \\(t\\). A fórmula é a seguinte:\n\\[\nS(t) = \\prod_{i:t_i\\leq t} (1 - \\frac{d_i}{n_i})\n\\]\n\\(S(t)\\) é a função de sobrevivência, ou seja, a probabilidade estimada de que uma ADPF inda esteja em tramitação após um tempo \\(t\\). O símbolo \\(\\prod\\) é o produtório, que indica a multiplicação sucessiva de termos. O índice \\(t_i\\leq t\\) significa que estamos multiplicando os termos para todos os momentos \\(t_i\\) em que um processo foi baixado, desde o início do acompanhamento até o tempo \\(t\\). O elemento \\(d_i\\) representa o número de processos que tiveram baixa exatamente no tempo \\(t_i\\). Por fim, \\(n_i\\) representa o número total de processos que estavam sob risco de serem baixados imediatamenteantes do tempo \\(t_i\\), isto é, todos os processos que ainda estavam ativos naquele momento.\nO termo central \\(\\frac{d_i}{n_i}\\) representa o risco instantâneo de um processo ser baixado no tempo \\(t_i\\). É a proporção de processos baixados dentre todos que estavam ativos. Consequentemente, a expressão \\((1-\\frac{d_i}{n_i})\\) representa a probabilidade de um processo não ser baixado naquele exato momento, ou seja, de sobreviver ao tempo \\(t_i\\), dado que ele já havia sobrevivido até ali. Ao multiplicar essas probabilidade de sobrevivência em cada etapa, calculamos a probabilidade acumulada de um processo ter sobrevivido a todos os momentos de risco até o tempo \\(t\\).\nAo quantificar a dimensão temporal da prestação jurisdicional em ADPFs de forma precisa, controlando os efeitos dos processos ainda em curso, esta pesquisa pode fundamentar suas conclusões em evidências sistemáticas, e não apenas em observações anedóticas ou estudos de caso isolados. A análise da curva de sobrevivência permitirá identificar períodos críticos na tramitação dos processos e oferecerá uma base sólida para discutir a capacidade institucional do STF em responder, em tempo hábil, às complexas demandas que lhe são apresentadas pelos atores políticos.\nApós a aplicação do estimador de Kaplan-Meier, que nos permite descrever a probabilidade de uma ADPF permanecer em tramitação ao longo do tempo, a investigação avança para uma questão mais complexa e explicativa: quais fatores ou características influenciam essa duração? Enquanto a análise de Kaplan-Meier nos mostra o quê acontece com a taxa de finalização dos processos, ela não nos informa o porquê. Por que algumas ADPFs são julgadas em poucos meses, enquanto outras perduram por mais de uma década no Supremo Tribunal Federal (STF)? Para responder a essa pergunta, a metodologia desta pesquisa emprega o modelo de regressão de riscos proporcionais de Cox. Este é um passo analítico subsequente e mais sofisticado, que nos permite avaliar o impacto de múltiplas variáveis (covariáveis) sobre o tempo de tramitação processual, identificando os fatores que aceleram ou retardam a baixa definitiva de uma ADPF.\n\n\n2.3.2 Regressão Logística",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Metodologia</span>"
    ]
  },
  {
    "objectID": "02_metodologia.html#análise-qualitativa",
    "href": "02_metodologia.html#análise-qualitativa",
    "title": "2  Metodologia",
    "section": "2.4 Análise qualitativa",
    "text": "2.4 Análise qualitativa",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Metodologia</span>"
    ]
  },
  {
    "objectID": "code.html",
    "href": "code.html",
    "title": "Apêndice A — Código",
    "section": "",
    "text": "Introdução",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Código</span>"
    ]
  },
  {
    "objectID": "code.html#metodologia",
    "href": "code.html#metodologia",
    "title": "Apêndice A — Código",
    "section": "Metodologia",
    "text": "Metodologia\n\nknitr::opts_chunk$set(\n  warning = FALSE, error = FALSE, message = FALSE\n)\n\n# Importa os processos\nraw_processos &lt;- readxl::read_xlsx(\"DATA/RAW/raw_processos.xlsx\", na = \"*NI*\")\n\n# Importa as decisões\nraw_decisoes &lt;- readxl::read_xlsx(\"DATA/RAW/raw_decisoes.xlsx\",\n  na = \"*NI*\",\n  col_types = c(\"guess\", \"date\", \"guess\", \"guess\", \"guess\", \"guess\")\n)\n\n# Importa os legitimados\nraw_legitimados &lt;- readxl::read_xlsx(\"DATA/RAW/raw_legitimados.xlsx\",\n  na = \"*NI*\"\n)\n\n# Salvar os arquivos raw em rds\nsaveRDS(raw_processos, \"DATA/RAW/raw_processos.rds\")\nsaveRDS(raw_decisoes, \"DATA/RAW/raw_decisoes.rds\")\nsaveRDS(raw_legitimados, \"DATA/RAW/raw_legitimados.rds\")\n\n# Extrai as decisões monocráticas\nraw_monocraticas &lt;- decJ::stf_jurisprudencia(\n  classe = \"ADPF\",\n  base = 'decisoes',\n  quantidade = 3000\n)\n\n# Extrai os acórdãos\nraw_acordaos &lt;- decJ::stf_jurisprudencia(\n  classe = \"ADPF\",\n  base = \"acordaos\",\n  quantidade = 3000\n)\n\n# Salva os arquivos raw em rds\nsaveRDS(raw_monocraticas, \"DATA/RAW/raw_monocraticas.rds\")\nsaveRDS(raw_acordaos, \"DATA/RAW/raw_acordaos.rds\")\n\n# Função stf_jurisprudencia do pacote decJ\n\nstf_jurisprudencia = function(busca = NULL, classe = NULL, base = c(\"acordaos\", \"decisoes\"), quantidade = 25){\n\n  header &lt;- httr::add_headers(\"User-Agent\" = \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.51\")\n\n  if (!is.null(busca) & is.null(classe)) {\n    body &lt;- busca_jurisprudencia\n    body$query$bool$filter[[1]]$query_string$query &lt;- busca\n    body$post_filter$bool$must[[1]]$term$base &lt;- base\n  } else if (is.null(busca) & !is.null(classe)) {\n    body &lt;- busca_classe\n    body$query$bool$filter$query_string$query &lt;- classe\n    body$post_filter$bool$must$term$base &lt;- base\n  } else if ((!is.null(busca) & !is.null(classe))) {\n    cli::cli_alert_danger(\"Essa funcao so funciona com busca por palavras chaves OU por classe. Ainda estamos desenvolvendo uma forma de trabalhar com as duas buscas juntas.\")\n    return(NULL)\n  }\n\n  num_iteracoes &lt;- ceiling(quantidade / 250)\n\n  if (quantidade &gt; 250) {\n    body$size &lt;- 250\n  } else {\n    body$size &lt;- quantidade\n  }\n \n  purrr::map_dfr(1:num_iteracoes, purrr::slowly(~{ \n    body$from &lt;- (.x - 1) * 250\n    htmlSTF &lt;- httr::POST(\n      \"https://jurisprudencia.stf.jus.br/api/search/search\",\n      body = body,\n      encode = \"json\", header\n    )\n    getContent &lt;- jsonlite::fromJSON(httr::content(htmlSTF, \"text\"))\n    dados &lt;- getContent$result$hits$hits$`_source`\n  }, rate = purrr::rate_delay(5)), .progress = list(format = \"Extraindo {cli::pb_bar} {cli::pb_elapsed}\")) \n}\n\n# Faz a leitura dos arquivos raw para utilizar no script\nraw_processos &lt;- readRDS('DATA/RAW/raw_processos.rds')\nraw_decisoes &lt;- readRDS('DATA/RAW/raw_decisoes.rds')\nraw_legitimados &lt;- readRDS('DATA/RAW/raw_legitimados.rds')\nraw_monocraticas &lt;- readRDS('DATA/RAW/raw_monocraticas.rds')\nraw_acordaos &lt;- readRDS('DATA/RAW/raw_acordaos.rds')\n\n# Cria uma tabela com as informações dos dados raw\ntibble::tribble(\n  ~\"Tabela\", ~\"Nº Colunas\", ~\"Nº Linhas\", ~\"Nº de Dados\",\n  \"raw_processos\", ncol(raw_processos), nrow(raw_processos), ncol(raw_processos) * nrow(raw_processos),\n  \"raw_decisoes\", ncol(raw_decisoes), nrow(raw_decisoes), ncol(raw_decisoes) * nrow(raw_decisoes),\n  \"raw_legitimados\", ncol(raw_legitimados), nrow(raw_legitimados), ncol(raw_legitimados) * nrow(raw_legitimados),\n  \"raw_acordaos\", ncol(raw_acordaos), nrow(raw_acordaos), ncol(raw_acordaos) * nrow(raw_acordaos),\n  \"raw_monocraticas\", ncol(raw_monocraticas), nrow(raw_monocraticas), ncol(raw_monocraticas) * nrow(raw_monocraticas)\n) |&gt; knitr::kable()\n\n# Limpa o nome das variáveis\nclean_processos &lt;- janitor::clean_names(raw_processos)\nclean_decisoes &lt;- janitor::clean_names(raw_decisoes)\nclean_legitimados &lt;- janitor::clean_names(raw_legitimados)\nclean_acordaos &lt;- janitor::clean_names(raw_acordaos)\nclean_monocraticas &lt;- janitor::clean_names(raw_monocraticas)\n\nclean_processos &lt;- clean_processos |&gt;\n  # seleciona as colunas que serão utilizadas\n  dplyr::select(\n    processo, link_processo, relator_atual, ramo_do_direito, assunto_relacionado, data_autuacao, data_transito_julgado, data_baixa, em_tramitacao, tem_rito_art_12, legislacao\n  ) |&gt;\n  # transforma as colunas de data \n  dplyr::mutate(\n    data_autuacao = lubridate::ymd(as.Date(data_autuacao)),\n    data_transito_julgado = lubridate::ymd(as.Date(data_transito_julgado)),\n    data_baixa = lubridate::ymd(as.Date(data_baixa, format = \"%d/%m/%Y\"))\n  ) |&gt;\n  # separa processo em classe e numero\n  tidyr::separate(\n    processo,\n    into = c(\"classe\", \"numero\"),\n    sep = \"\\\\s\"\n  ) |&gt;\n  # separa os assuntos relacionados\n  tidyr::separate_rows(\n    assunto_relacionado,\n    sep = \"\\\\|\"\n  ) |&gt;\n  # separa a legislação\n  tidyr::separate_rows(\n    legislacao,\n    sep = \"\\\\r\"\n  )\n\n# Salva a tabela limpa\nsaveRDS(clean_processos, \"DATA/CLEAN/clean_processos.rds\")",
    "crumbs": [
      "Apêndices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>Código</span>"
    ]
  }
]