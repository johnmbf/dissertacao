# Apêndice A - Como os dados foram coletados? {#sec-apendice-a}

```{r, setup-apendice-a}
#| include: false

knitr::opts_chunk$set(
  warning = FALSE, error = FALSE, message = FALSE, eval = FALSE
)
```

Os dados foram coletados do portal Corte Aberta do STF, painéis estatísticos de controle concentrado que podem ser acessados [aqui](https://transparencia.stf.jus.br/extensions/controle_concentrado/controle_concentrado.html). Foram baixados três tabelas do portal e armazenados na pasta `DATA/RAW/`.

Uma vez baixados os dados, eles foram importados utilizando a função `readxl::read_xlsx()`:

```{r, imp-1, eval=FALSE}
# Importa os processos
raw_processos <- readxl::read_xlsx("DATA/RAW/raw_processos.xlsx", na = "*NI*")

# Importa as decisões
raw_decisoes <- readxl::read_xlsx("DATA/RAW/raw_decisoes.xlsx",
  na = "*NI*",
  col_types = c("guess", "date", "guess", "guess", "guess", "guess")
  

# Importa os legitimados
raw_legitimados <- readxl::read_xlsx("DATA/RAW/raw_legitimados.xlsx",
  na = "*NI*"
)
```

Após importar os dados, salvei eles em formato `.rds` para leitura mais posterior mais rápida:

```{r, imp-2, eval=FALSE}
# Salvar os arquivos raw em rds
saveRDS(raw_processos, "DATA/RAW/raw_processos.rds")
saveRDS(raw_decisoes, "DATA/RAW/raw_decisoes.rds")
saveRDS(raw_legitimados, "DATA/RAW/raw_legitimados.rds")
```

O segundo conjunto de dados foram obtidos a partir da raspagem de dados no portal do STF. Primeiro, extraiu-se os dados sobre decisões monocráticas e acórdãos, depois, com base na tabela de acórdãos, foram baixados os arquivos em `.pdf` dos acórdãos. Para isso, foi utilizado o pacote `decJ`.

```{r, dec-imp, eval=FALSE}
# Extrai as decisões monocráticas
raw_monocraticas <- decJ::stf_jurisprudencia(
  classe = "ADPF",
  base = 'decisoes',
  quantidade = 3000
)

# Extrai os acórdãos
raw_acordaos <- decJ::stf_jurisprudencia(
  classe = "ADPF",
  base = "acordaos",
  quantidade = 3000
)

# Salva os arquivos raw em rds
saveRDS(raw_monocraticas, "DATA/RAW/raw_monocraticas.rds")
saveRDS(raw_acordaos, "DATA/RAW/raw_acordaos.rds")
```

A função `decJ::stf_jurisprudencia()` funciona da seguinte forma:

```{r, decj-juris, eval=FALSE}
# Função stf_jurisprudencia do pacote decJ

stf_jurisprudencia = function(busca = NULL, classe = NULL, base = c("acordaos", "decisoes"), quantidade = 25){

  header <- httr::add_headers("User-Agent" = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36 Edg/114.0.1823.51")

  if (!is.null(busca) & is.null(classe)) { 
    body <- busca_jurisprudencia 
    body$query$bool$filter[[1]]$query_string$query <- busca
    body$post_filter$bool$must[[1]]$term$base <- base 
  } else if (is.null(busca) & !is.null(classe)) { 
    body <- busca_classe 
    body$query$bool$filter$query_string$query <- classe 
    body$post_filter$bool$must$term$base <- base 
  } else if ((!is.null(busca) & !is.null(classe))) { 
    cli::cli_alert_danger("Essa funcao so funciona com busca por palavras chaves OU por classe. Ainda estamos desenvolvendo uma forma de trabalhar com as duas buscas juntas.")
    return(NULL) 
  }

  num_iteracoes <- ceiling(quantidade / 250) # <3>

  if (quantidade > 250) {
    body$size <- 250
  } else {
    body$size <- quantidade
  }
 
  purrr::map_dfr(1:num_iteracoes, purrr::slowly(~{ 
    body$from <- (.x - 1) * 250
    htmlSTF <- httr::POST( # <4>
      "https://jurisprudencia.stf.jus.br/api/search/search",
      body = body, # <4>
      en = "json", header # <4>
    ) # <4>
    getContent <- jsonlite::fromJSON(httr::content(htmlSTF, "text"))
    dados <- getContent$result$hits$hits$`_source` # <4>
  }, rate = purrr::rate_delay(5)), .progress = list(format = "Extraindo {cli::pb_bar} {cli::pb_elapsed}")) 
}
```

Estas então foram as formas de coletar os dados brutos. Abaixo podemos observar a estrutura dessas tabelas:

```{r, imp-3, include=FALSE}
# Faz a leitura dos arquivos raw para utilizar no script
raw_processos <- readRDS('DATA/RAW/raw_processos.rds')
raw_decisoes <- readRDS('DATA/RAW/raw_decisoes.rds')
raw_legitimados <- readRDS('DATA/RAW/raw_legitimados.rds')
raw_monocraticas <- readRDS('DATA/RAW/raw_monocraticas.rds')
raw_acordaos <- readRDS('DATA/RAW/raw_acordaos.rds')
```

```{r, imp-4, echo=FALSE}
# Cria uma tabela com as informações dos dados raw
tibble::tribble(
  ~"Tabela", ~"Nº Colunas", ~"Nº Linhas", ~"Nº de Dados",
  "raw_processos", ncol(raw_processos), nrow(raw_processos), ncol(raw_processos) * nrow(raw_processos),
  "raw_decisoes", ncol(raw_decisoes), nrow(raw_decisoes), ncol(raw_decisoes) * nrow(raw_decisoes),
  "raw_legitimados", ncol(raw_legitimados), nrow(raw_legitimados), ncol(raw_legitimados) * nrow(raw_legitimados),
  "raw_acordaos", ncol(raw_acordaos), nrow(raw_acordaos), ncol(raw_acordaos) * nrow(raw_acordaos),
  "raw_monocraticas", ncol(raw_monocraticas), nrow(raw_monocraticas), ncol(raw_monocraticas) * nrow(raw_monocraticas)
) |> knitr::kable()
```

## Limpeza dos dados

Uma vez obtidos os dados brutos, foi preciso fazer uma faxina inicial. Primeiro, limpei o nome das variáveis:

```{r, limp-1}
# Limpa o nome das variáveis
clean_processos <- janitor::clean_names(raw_processos)
clean_decisoes <- janitor::clean_names(raw_decisoes)
clean_legitimados <- janitor::clean_names(raw_legitimados)
clean_acordaos <- janitor::clean_names(raw_acordaos)
clean_monocraticas <- janitor::clean_names(raw_monocraticas)
```

Após a limpeza dos nomes das variáveis de todas as tabelas, passei a limpar tabelas específicas. Começando pela tabela de processos (`clean_processos`).

```{r, limp-2}
clean_processos <- clean_processos |>
  # seleciona as colunas que serão utilizadas
  dplyr::select(
    processo, link_processo, relator_atual, ramo_do_direito, assunto_relacionado, data_autuacao, data_transito_julgado, data_baixa, em_tramitacao, tem_rito_art_12, legislacao
  ) |>
  # transforma as colunas de data 
  dplyr::mutate(
    data_autuacao = lubridate::ymd(as.Date(data_autuacao)),
    data_transito_julgado = lubridate::ymd(as.Date(data_transito_julgado)),
    data_baixa = lubridate::ymd(as.Date(data_baixa, format = "%d/%m/%Y"))
  ) |>
  # separa processo em classe e numero
  tidyr::separate(
    processo,
    into = c("classe", "numero"),
    sep = "\\s"
  ) |>
  # separa os assuntos relacionados
  tidyr::separate_rows(
    assunto_relacionado,
    sep = "\\|"
  ) |>
  # separa a legislação
  tidyr::separate_rows(
    legislacao,
    sep = "\\r"
  )

# Salva a tabela limpa
saveRDS(clean_processos, "DATA/CLEAN/clean_processos.rds")
```

A segunda tabela que apliquei a faxina foi a tabela que contém as decisões (`clean_decisoes`). A tabela criada considera apenas as decisões cujo resultado foi procedente, improcedente, procedente em parte ou prejudicado. Posteriormente, as ações que tiverem "em tramitação" igual a "não" na tabela de processos e não retornarem esses resultados, serão consideradas sem resolução de mérito.

```{r, limp-3}
clean_decisoes <- clean_decisoes |>
  # retira a coluna observação e descrição
  dplyr::select(-observacao, descricao) |>
  # transforma a coluna de data 
  dplyr::mutate(data = lubridate::ymd(as.Date(data))) |>
  # separa processo em classe e numero |>
  tidyr::separate(
    processo,
    into = c("classe", "numero"),
    sep = "\\s"
  ) |>
  # transforma o texto da coluna descricao em minusculo
  dplyr::mutate(descricao = stringr::str_to_lower(descricao))

# Salva a tabela limpa
saveRDS(clean_decisoes, "DATA/CLEAN/clean_decisoes.rds")
```

A teceira tabela envolve os legitimados (`clean_legitimados`):

```{r, limp-4}
clean_legitimados <- clean_legitimados |>
  # retira os acentos
  dplyr::mutate(dplyr::across(c("legitimado_polo_ativo", "legitimado_polo_passivo"), decJ::utilitario_remover_acentos)) |>
  # separa processo em classe e numero
  tidyr::separate(
    processo,
    into = c("classe", "numero"),
    sep = "\\s"
  )

# Salva a tabela limpa
saveRDS(clean_legitimados, "DATA/CLEAN/clean_legitimados.rds")
```

A limpeza da tabela com as decisões monocráticas e os acórdãos envolveu, basicamente, selecionar as colunas de interesse.

```{r, limp-5}
clean_monocraticas <- clean_monocraticas |>
  # seleciona e renomeia as colunas de interesse
  dplyr::select(id, uf = procedencia_geografica_uf_sigla, numero = processo_numero, data = julgamento_data, texto = decisao_texto)

clean_acordaos <- clean_acordaos |>
  # seleciona e renomeia as colunas de interesse
  dplyr::select(id, uf = procedencia_geografica_uf_sigla, numero = processo_numero, data = julgamento_data, texto = ementa_texto, url = inteiro_teor_url)

# Salva as tabelas limpas
saveRDS(clean_monocraticas, "DATA/CLEAN/clean_monocraticas.rds")
saveRDS(clean_acordaos, "DATA/CLEAN/clean_acordaos.rds")
```

Serão feitas limpezas específicas dos dados a depender da análise. Essas limpezas estarão descritas no momento da análise no capítulo respectivo.